"""
This type stub file was generated by pyright.
"""

import logging
import os
import socket
import sys

__version__ = "1.7.1"
if os.name == "nt" and sys.version_info < (3, 0):
    ...
log = logging.getLogger(__name__)
PROXY_TYPE_SOCKS4 = SOCKS4 = 1
PROXY_TYPE_SOCKS5 = SOCKS5 = 2
PROXY_TYPE_HTTP = HTTP = 3
PROXY_TYPES = { "SOCKS4": SOCKS4,"SOCKS5": SOCKS5,"HTTP": HTTP }
PRINTABLE_PROXY_TYPES = dict(zip(PROXY_TYPES.values(), PROXY_TYPES.keys()))
_orgsocket = _orig_socket = socket.socket
def set_self_blocking(function):
    ...

class ProxyError(IOError):
    """Socket_err contains original socket.error exception."""
    def __init__(self, msg, socket_err=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class GeneralProxyError(ProxyError):
    ...


class ProxyConnectionError(ProxyError):
    ...


class SOCKS5AuthError(ProxyError):
    ...


class SOCKS5Error(ProxyError):
    ...


class SOCKS4Error(ProxyError):
    ...


class HTTPError(ProxyError):
    ...


SOCKS4_ERRORS = { 91: "Request rejected or failed",92: "Request rejected because SOCKS server cannot connect to identd on" " the client",93: "Request rejected because the client program and identd report" " different user-ids" }
SOCKS5_ERRORS = { 1: "General SOCKS server failure",2: "Connection not allowed by ruleset",3: "Network unreachable",4: "Host unreachable",5: "Connection refused",6: "TTL expired",7: "Command not supported, or protocol error",8: "Address type not supported" }
DEFAULT_PORTS = { SOCKS4: 1080,SOCKS5: 1080,HTTP: 8080 }
def set_default_proxy(proxy_type=..., addr=..., port=..., rdns=..., username=..., password=...):
    """Sets a default proxy.

    All further socksocket objects will use the default unless explicitly
    changed. All parameters are as for socket.set_proxy()."""
    ...

def setdefaultproxy(*args, **kwargs):
    ...

def get_default_proxy():
    """Returns the default proxy, set by set_default_proxy."""
    ...

getdefaultproxy = get_default_proxy
def wrap_module(module):
    """Attempts to replace a module's socket library with a SOCKS socket.

    Must set a default proxy using set_default_proxy(...) first. This will
    only work on modules that import socket directly into the namespace;
    most of the Python Standard Library falls into this category."""
    ...

wrapmodule = wrap_module
def create_connection(dest_pair, timeout=..., source_address=..., proxy_type=..., proxy_addr=..., proxy_port=..., proxy_rdns=..., proxy_username=..., proxy_password=..., socket_options=...):
    """create_connection(dest_pair, *[, timeout], **proxy_args) -> socket object

    Like socket.create_connection(), but connects to proxy
    before returning the socket object.

    dest_pair - 2-tuple of (IP/hostname, port).
    **proxy_args - Same args passed to socksocket.set_proxy() if present.
    timeout - Optional socket timeout value, in seconds.
    source_address - tuple (host, port) for the socket to bind to as its source
    address before connecting (only for compatibility)
    """
    ...

class _BaseSocket(socket.socket):
    """Allows Python 2 delegated methods such as send() to be overridden."""
    def __init__(self, *pos, **kw) -> None:
        ...
    
    _savenames = ...


class socksocket(_BaseSocket):
    """socksocket([family[, type[, proto]]]) -> socket object

    Open a SOCKS enabled socket. The parameters are the same as
    those of the standard socket init. In order for SOCKS to work,
    you must specify family=AF_INET and proto=0.
    The "type" argument must be either SOCK_STREAM or SOCK_DGRAM.
    """
    default_proxy = ...
    def __init__(self, family=..., type=..., proto=..., *args, **kwargs) -> None:
        ...
    
    def settimeout(self, timeout):
        ...
    
    def gettimeout(self):
        ...
    
    def setblocking(self, v):
        ...
    
    def set_proxy(self, proxy_type=..., addr=..., port=..., rdns=..., username=..., password=...):
        """ Sets the proxy to be used.

        proxy_type -  The type of the proxy to be used. Three types
                        are supported: PROXY_TYPE_SOCKS4 (including socks4a),
                        PROXY_TYPE_SOCKS5 and PROXY_TYPE_HTTP
        addr -        The address of the server (IP or DNS).
        port -        The port of the server. Defaults to 1080 for SOCKS
                        servers and 8080 for HTTP proxy servers.
        rdns -        Should DNS queries be performed on the remote side
                       (rather than the local side). The default is True.
                       Note: This has no effect with SOCKS4 servers.
        username -    Username to authenticate with to the server.
                       The default is no authentication.
        password -    Password to authenticate with to the server.
                       Only relevant when username is also provided."""
        ...
    
    def setproxy(self, *args, **kwargs):
        ...
    
    def bind(self, *pos, **kw):
        """Implements proxy connection for UDP sockets.

        Happens during the bind() phase."""
        ...
    
    def sendto(self, bytes, *args, **kwargs):
        ...
    
    def send(self, bytes, flags=..., **kwargs):
        ...
    
    def recvfrom(self, bufsize, flags=...):
        ...
    
    def recv(self, *pos, **kw):
        ...
    
    def close(self):
        ...
    
    def get_proxy_sockname(self):
        """Returns the bound IP address and port number at the proxy."""
        ...
    
    getproxysockname = ...
    def get_proxy_peername(self):
        """
        Returns the IP and port number of the proxy.
        """
        ...
    
    getproxypeername = ...
    def get_peername(self):
        """Returns the IP address and port number of the destination machine.

        Note: get_proxy_peername returns the proxy."""
        ...
    
    getpeername = ...
    _proxy_negotiators = ...
    @set_self_blocking
    def connect(self, dest_pair, catch_errors=...):
        """
        Connects to the specified destination through a proxy.
        Uses the same API as socket's connect().
        To select the proxy server, use set_proxy().

        dest_pair - 2-tuple of (IP/hostname, port).
        """
        ...
    
    @set_self_blocking
    def connect_ex(self, dest_pair):
        """ https://docs.python.org/3/library/socket.html#socket.socket.connect_ex
        Like connect(address), but return an error indicator instead of raising an exception for errors returned by the C-level connect() call (other problems, such as "host not found" can still raise exceptions).
        """
        ...
    


